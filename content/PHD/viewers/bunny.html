<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { margin:0; height:100%; overflow:hidden; background:white; }
    .dual { 
      position:relative;
      display:flex;
      width:100%;
      height: 100%;
      gap: 20%;   
    }
    canvas {
      flex: 1 1 0;
      min-width: 0;
      display: block;
      /* supprime: width:50%; */
    }
  </style>
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
    }
  }
  </script>
</head>
<body>
  <div class="dual" id="dual">
    <canvas id="canvasLeft"></canvas>
    <canvas id="canvasRight" style="transform: translateX(20%);"></canvas>
  </div>

  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js";
    import { PLYLoader }   from "https://unpkg.com/three@0.160.0/examples/jsm/loaders/PLYLoader.js";

    const container = document.getElementById("dual");
    const canvasL = document.getElementById("canvasLeft");
    const canvasR = document.getElementById("canvasRight");

    // --- Renderers (physically-correct + ACES) ---
    // const rendererL = new THREE.WebGLRenderer({ canvas: canvasL, antialias: true });
    // const rendererR = new THREE.WebGLRenderer({ canvas: canvasR, antialias: true });

    const opts = { antialias: true, powerPreference: "high-performance" };
    const rendererL = new THREE.WebGLRenderer({ canvas: canvasL, ...opts });
    const rendererR = new THREE.WebGLRenderer({ canvas: canvasR, ...opts });

    const dpr = Math.min(window.devicePixelRatio || 1, 2.5); // 2–3 max selon perf
    for (const r of [rendererL, rendererR]) {
      // r.setPixelRatio(window.devicePixelRatio || 1);
      r.setPixelRatio(dpr);
      r.shadowMap.enabled = false; // pas utile ici sans sol
      r.toneMapping = THREE.ACESFilmicToneMapping;
      r.toneMappingExposure = 1.0;
      r.outputColorSpace = THREE.SRGBColorSpace;
      r.physicallyCorrectLights = true;
    }

    // --- Scenes ---
    const sceneL = new THREE.Scene();
    const sceneR = new THREE.Scene();
    sceneL.background = new THREE.Color(0xffffff);
    sceneR.background = new THREE.Color(0xffffff);

    // --- Cameras & controls (gauche = maître) ---
    const cameraL = new THREE.PerspectiveCamera(60, 1, 0.01, 100);
    const cameraR = new THREE.PerspectiveCamera(60, 1, 0.01, 100);
    cameraL.zoom = 2.0;
    cameraR.zoom = 2.0;
    cameraL.updateProjectionMatrix();
    cameraR.updateProjectionMatrix();
    cameraL.position.set(2.4, 1.9, 2.6);
    cameraR.position.copy(cameraL.position);
    cameraL.lookAt(0,0,0);
    cameraR.lookAt(0,0,0);

    const controlsL = new OrbitControls(cameraL, rendererL.domElement);
    controlsL.enableDamping = true;
    controlsL.dampingFactor = 0.08;
    controlsL.target.set(0,0,0);
    controlsL.update();

    function syncCamera() {
      cameraR.position.copy(cameraL.position);
      cameraR.quaternion.copy(cameraL.quaternion);
      cameraR.zoom = cameraL.zoom;
      cameraR.projectionMatrix.copy(cameraL.projectionMatrix);
      cameraR.updateMatrixWorld(true);
    }
    controlsL.addEventListener("change", syncCamera);
    syncCamera();

    // --- Lumières douces (affecte le mesh; le point cloud est unlit) ---
    function setupLights(scene) {
      const key = new THREE.DirectionalLight(0xffffff, 2.5); key.position.set(3,5,3);
      const fill = new THREE.DirectionalLight(0xffffff, 1.2); fill.position.set(-4,2,1);
      const rim = new THREE.DirectionalLight(0xffffff, 1.4); rim.position.set(-2,4,-4);
      const hemi = new THREE.HemisphereLight(0xE8F0FF, 0xFFFFFF, 0.5);
      scene.add(key, fill, rim, hemi);
    }
    setupLights(sceneL);
    setupLights(sceneR);

    function makeCircularTexture() {
      const size = 256;
      const canvas = document.createElement('canvas');
      canvas.width = canvas.height = size;
      const ctx = canvas.getContext('2d');
      const gradient = ctx.createRadialGradient(
        size / 2, size / 2, 0, size / 2, size / 2, size / 2
      );
      gradient.addColorStop(0, 'white');
      gradient.addColorStop(1, 'black');
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(size / 2, size / 2, size / 2, 0, 2 * Math.PI);
      ctx.fill();
      const texture = new THREE.CanvasTexture(canvas);
      texture.colorSpace = THREE.SRGBColorSpace;
      texture.generateMipmaps = true;
      texture.minFilter = THREE.LinearMipmapLinearFilter;
      texture.magFilter = THREE.LinearFilter;
      // anisotropie (prends un renderer, peu importe lequel)
      texture.anisotropy = Math.min(rendererL.capabilities.getMaxAnisotropy(), 8);
      return texture;
    }

    // --- Matériaux ---
    const meshMat = new THREE.MeshPhysicalMaterial({
      color: 0x2b7cff, roughness: 0.2, metalness: 0.05,
      clearcoat: 1.0, clearcoatRoughness: 0.06,
      sheen: 1.0, sheenRoughness: 0.4, sheenColor: new THREE.Color(0x99ccff)
    });
    // const pcdMatNoColor = new THREE.PointsMaterial({
    //   size: 0.03, sizeAttenuation: true, color: 0x333333
    // });
    const pcdMatNoColor = new THREE.PointsMaterial({
      size: 0.04,
      sizeAttenuation: true,
      color: 0x333333,
      map: makeCircularTexture(),
      alphaTest: 0.5,
      transparent: true
    });
    // Si le PLY a des couleurs, on activera vertexColors plus bas.

    // --- Chargement PLYs ---
    const MESH_PATH = "../assets/BunnyMesh.ply";
    const PCD_PATH  = "../assets/BunnyPcd.ply";
    const loader = new PLYLoader();

    const loadPLY = (url) => new Promise((resolve, reject) => {
      loader.load(url, (geom) => resolve(geom), undefined, reject);
    });

    // Helper: calcule bbox/bounds combinés
    function combinedBounds(geoms) {
      const min = new THREE.Vector3(+Infinity, +Infinity, +Infinity);
      const max = new THREE.Vector3(-Infinity, -Infinity, -Infinity);
      for (const g of geoms) {
        g.computeBoundingBox();
        min.min(g.boundingBox.min);
        max.max(g.boundingBox.max);
      }
      const center = new THREE.Vector3().addVectors(min, max).multiplyScalar(0.5);
      // rayon approx = max distance centre -> sommets des bboxes
      const corners = [
        new THREE.Vector3(min.x,min.y,min.z), new THREE.Vector3(min.x,min.y,max.z),
        new THREE.Vector3(min.x,max.y,min.z), new THREE.Vector3(min.x,max.y,max.z),
        new THREE.Vector3(max.x,min.y,min.z), new THREE.Vector3(max.x,min.y,max.z),
        new THREE.Vector3(max.x,max.y,min.z), new THREE.Vector3(max.x,max.y,max.z)
      ];
      let radius = 0;
      for (const c of corners) radius = Math.max(radius, c.distanceTo(center));
      return { center, radius: Math.max(radius, 1e-6) };
    }

    // Charge les deux, normalise ensemble, instancie dans chaque scène
    Promise.all([ loadPLY(MESH_PATH), loadPLY(PCD_PATH) ]).then(([meshGeom, pcdGeom]) => {
      // Normales pour le mesh
      meshGeom.computeVertexNormals();

      // Borne combinée → centrage + mise à l’échelle identique pour les deux
      const { center, radius } = combinedBounds([meshGeom, pcdGeom]);
      const targetRadius = 0.8;
      const s = targetRadius / radius;

      // Applique centre/scale aux deux géométries (in place)
      meshGeom.translate(-center.x, -center.y, -center.z);
      pcdGeom.translate(-center.x, -center.y, -center.z);
      meshGeom.scale(s, s, s);
      pcdGeom.scale(s, s, s);

      // Mesh à gauche
      const mesh = new THREE.Mesh(meshGeom, meshMat);
      sceneL.add(mesh);
      mesh.position.y += 0.3;

      // Point cloud à droite
      const hasColors = !!pcdGeom.attributes.color;
      const pcdMat = hasColors
        ? new THREE.PointsMaterial({ size: 0.03, sizeAttenuation: true, vertexColors: true })
        : pcdMatNoColor;
      const points = new THREE.Points(pcdGeom, pcdMat);
      sceneR.add(points);
      points.position.y += 0.3;

      // Ajuste la cible caméra si besoin
      controlsL.target.set(0, 0, 0);
      controlsL.update();
      syncCamera();
    }).catch(err => {
      console.error("Erreur de chargement PLY:", err);
    });

    // --- Resize ---
    function resize() {
      // Mesure la taille RÉELLE de chaque canvas
      const rectL = canvasL.getBoundingClientRect();
      const rectR = canvasR.getBoundingClientRect();

      const wl = Math.max(1, rectL.width);
      const hl = Math.max(1, rectL.height);
      const wr = Math.max(1, rectR.width);
      const hr = Math.max(1, rectR.height);

      // Ajuste chaque renderer à son canvas
      rendererL.setSize(wl, hl, false);
      rendererR.setSize(wr, hr, false);

      // Met à jour l’aspect de chaque caméra
      cameraL.aspect = wl / hl;
      cameraR.aspect = wr / hr;
      cameraL.updateProjectionMatrix();
      cameraR.updateProjectionMatrix();
    }

    new ResizeObserver(resize).observe(container);
    resize();

    // --- Loop ---
    function tick() {
      controlsL.update();
      rendererL.render(sceneL, cameraL);
      rendererR.render(sceneR, cameraR);
      requestAnimationFrame(tick);
    }
    tick();
  </script>
</body>
</html>
